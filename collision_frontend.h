/**
 * Utilities for clash detection with broad-phase acceleration against static
 * geometry.
 */

#ifndef collision_frontend_h
#define collision_frontend_h

#include "collision_grid_prot.h"
#include "collision_logger.h"
#include "membrane.h"
#include "misc_structs.h"

#include <vector>

/**
 * Encapsulate collision routines
 */
class CollisionFrontend {
private:

public:

    /**
     * Enumerated overlap factor offsets
     */
    enum eIxOFAC {
        /**
         * Squared overlap factor for atoms within adjacent residues
         */
        eIxOFAC_adj = 0,
        /**
         * Squared overlap factor for atoms between adjacent residues
         */
        eIxOFAC_nadj,
        /**
         * Squared overlap factor for membrane bilayer atoms
         */
         eIxOFAC_memb,
        /**
         * Number of overlap factor
         */
        eIxOFAC_num
    };
    
    /**
     * Initializes broad phase
     * @param markedConf - simulated loop regions must be moved to origin
     * @param params - command line arguments
     */
    void init(const class Structure &markedConf, const struct Params &params);

    /**
     * Prints clash statistics against broad phase only
     * @param Conf - the structure to check for clashes at loop regions
     * @param starts - vector of start residue indices for loop regions
     * @param ends - vector of end residue indices for loop regions
     * @param b_ignore_self - if true, then assume that broad phase was
     *  generated by Conf and 'self' collisions are ignored
     */
    void print_broad_clash_counts(const class Structure &Conf,
                                  const std::vector<int> &starts,
                                  const std::vector<int> &ends,
                                  const bool b_ignore_self) const;

    /**
     * gobbo - *g*row *o*ne *b*ack*b*one only
     * This method is only meant to be called from grow_one_bb_only() as
     * simplifying assumptions made are only valid for this use case.
     * Assumptions:
     *  -param res is a mixed residue containing only backbone atoms
     *      (with no side chain) and where atoms N and CA are for residue i+1
     *      and remaining backbone atoms are for residue i
     *  -simulated loop regions in param Conf can be ignored once the first
     *      non-hydrogen atom placed at origin is encountered
     *  -simulated loop regions have no side chains placed
     * @return true if residue backbone is clash free, false o/w
     */
    bool gobbo_is_bb_clash_free(const class Residue &res,
                                const class Structure &Conf,
                                const class SMC &smc) const;

    /**
     * Only meant to be called during multi-loop growth -
     * restarts a loop region for regrowth. If fragment libraries
     * are enabled, then a fragment is attempted to be used
     * @param LoopChosen - index of loop to regrow
     * @param multiloops - (start, end) residue indices for simulated loop regions
     * @param min_frag_len - minimum length of loop region to allow fragment
     *  library usage (if region is smaller than this value, fragment library usage
     *  is disabled)
     * @param tail_len - The amount of residues from end of fragment to not use
     * @param smc - the simulation object
     */
    void restart_loop(const int LoopChosen,
                      vector<loop_info> &multiloops,
                      const vector<int> &multilooplength,
                      const int min_frag_len,
                      const int tail_len,
                      class SMC &smc) const;

    /**
     * OVERLAP FACTORS
     * If the ratio of distance between two atoms centers to the sum of their
     * atomic radii is less than the overlap factor (ofac) value, then the atoms
     * are colliding.
     *
     * Jacobson, Matthew P., David L.Pincus, Chaya S.Rapp, Tyler JF Day, Barry Honig,
     * David E.Shaw, and Richard A.Friesner. "A hierarchical approach to all-atom protein loop prediction."
     * Proteins: Structure, Function, and Bioinformatics 55, no. 2 (2004) : 351 - 367.
     */

    /**
     * Obtain squared overlap factor (ofac)
     * @return adjacent ofac if residue indices are consecutive,
     *  and non-adjacent ofac otherwise
     */
    inline double get_ofac2(const int res_ix_a, const int res_ix_b) const {
        const int ix_diff = res_ix_a - res_ix_b;
        const int select = (ix_diff > 1) || (ix_diff < -1);
        assert(eIxOFAC_adj == 0);
        assert(eIxOFAC_nadj == 1);
        return this->m_ofac2[select];
    }

    /**
     * Obtain squared overlap factor (ofac)
     * @return enumerated overlap factor
     */
    inline double get_ofac2(enum eIxOFAC ix_ofac) const {
        assert(ix_ofac < eIxOFAC_num);
        return this->m_ofac2[ix_ofac];
    }

    COLLISION_LOGGER_DECLARE(clog)

private:

    /**
     * Squared overlap factors
     */
    double m_ofac2[eIxOFAC_num];

    /**
     * Spatial acceleration for broad phase collision checking
     */
    collision_grid_prot m_broad_phase;

    /**
     * Optional membrane (lipid bilayer)
     */
    Membrane m_membrane;
};

#endif // collision_frontend_h
